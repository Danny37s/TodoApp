import { createAsyncThunk, createSlice, isRejectedWithValue, PayloadAction } from "@reduxjs/toolkit";
import { TaskApi } from "../../api/Task";
import { RootState } from "../../app/store";
import { TaskDeletePayloadType, TaskPayloadType, TaskType } from "../../models/Task";
export interface TaskState {
  value?: TaskType[];
  isLoading:boolean
}
const initialState: TaskState = {
  isLoading: false,
};

export const getTask = createAsyncThunk(
  "task/getTask",
  async (userId: number, { rejectWithValue }) => {
    const response = await TaskApi.getTask(userId)
    // Nếu bị lỗi thì reject
    if (response.status < 200 || response.status >= 300) {
      return rejectWithValue(response);
    }
    return response;
  }
);

export const addTask = createAsyncThunk(
  'task/addTask',
  async(payload:TaskPayloadType,{rejectWithValue})=>{
    const response = await TaskApi.addTask(payload)
    if(response.status<200 || response.status>=300){
      return rejectWithValue(response)
    }
    return response
  })
  export const deleteTask = createAsyncThunk(
    'task/deleteTask',
    async(payload:TaskDeletePayloadType,{rejectWithValue})=>{
      const response = await TaskApi.deleteTask(payload)
      if(response.status<200 || response.status>=300){
        return rejectWithValue(response)
      }
      return response
    })

export const TaskSlice = createSlice({
  name: "task",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    createTask: (state) => {
      // Redux Toolkit allows us to write "mutating" logic in reducers. It
      // doesn't actually mutate the state because it uses the Immer library,
      // which detects changes to a "draft state" and produces a brand new
      // immutable state based off those changes
    },
    // Use the PayloadAction type to declare the contents of `action.payload`
    updateTask: (state, action: PayloadAction<TaskType>) => {},
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(getTask.pending, (state) => {
        state.isLoading = true;
      })
      .addCase(getTask.fulfilled, (state, action) => {
        state.isLoading = false;
        state.value = action.payload.data;
        console.log(action.payload.data);

      })
      .addCase(getTask.rejected, (state) => {
        state.isLoading = false;
      })
      .addCase(addTask.pending,(state)=>{
        state.isLoading = true;
      })

      .addCase(addTask.fulfilled,(state,{payload})=>{
        state.isLoading = false
        console.log(payload.data.data);
        state.value = payload.data.data
      })
      .addCase(addTask.rejected,(state)=>{
        state.isLoading = false
      })

      .addCase(deleteTask.pending,(state)=>{
        state.isLoading = true;
      })

      .addCase(deleteTask.fulfilled,(state,{payload})=>{
        state.isLoading = false
        state.value = payload.data.data
      })
      .addCase(deleteTask.rejected,(state)=>{
        state.isLoading = false
      })
  },
});

export const { createTask, updateTask } = TaskSlice.actions;
export const selectTask = (state: RootState) => state.task.value;
export const selectLoading = (state: RootState) => state.task.isLoading;
export default TaskSlice.reducer;
